## IPC가 필요한 이유

우리가 사용하는 프로세스들은 모두 유저 공간(user-mode)에서 각각 OS로부터 할당한 독립된 공간에서 실행되어 있다. 여기서 말하는 독립되어 있다는 의미는 다른 프로세스의 영향을 받지 않는다는 장점이 있지만, 독립되어 있는 만큼 별도의 설비가 없이는 서로 간에 통신이 어렵다는 문제가 있다. 하지만 하나의 프로그램을 실행하더라도 여러 프로세스끼리 협력이 필요한 상황이 있다.

 

예를 들어 특정 Task를 여러 개의 Sub Task로 나누어 더 빠르게 수행해야 한다거나, 동시에 많은 Task를 한 번에 처리해야 하는 경우가 있다. 이를 해결하고자 커널 영역 (kernel-mode)에서 IPC(Inter-Process Communication)라는 프로세스들 간에 통신을 제공하고 있다.

 

즉, IPC는 프로세스들 사이에 서로 데이터를 주고 받는 행위를 말한다. IPC는 크게 두 가지 모델로 나뉜다.

 

## IPC 모델: Shared Memory



![[운영체제] IPC - IPC 모델: Shared Memory](https://blog.kakaocdn.net/dn/EFX2u/btrlxgu7n7I/xhHC7LUE6T1c75wg3dmeZk/img.png)



 

### 공유 메모리 모델의 특징

- 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며, 공유한 메모리 영역에 읽기/쓰기를 통해 통신을 수행한다. (Read and Write)
- 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해 주게 되고, 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다. 공유 메모리가 설정되면, 그 이후의 통신은 커널의 관여 없이 진행이 가능하다.

 

### 공유 메모리 모델의 장점

- 커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.
- 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.

 

### 공유 메모리 모델의 단점

- 메시지 전달 방식이 아니기에 데이터를 읽어야 하는 시점을 알 수 없다.
- 예를 들어, 프로세스 A가 공유 메모리에 데이터를 전달해도 프로세스 B가 그것을 알 수 없다.
- 그렇기 때문에 별도의 동기화 기술이 필요하다.
- 동시에 같은 메모리 위치를 접근하는 위치가 발생할 수 있다. (공유 메모리에 접근할 프로세스 간의 Lock 메커니즘이 필요하다.)

 

### 예시

- POSIX: Portable OS interface (for UNIX)
- 공유 메모리 (Shared Memory)

 

## IPC 모델: 메시지 전달 (Message Passing)



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing)](https://blog.kakaocdn.net/dn/cmsQiy/btrlyZe6gQG/HgYGzkjztkHIrS6iLMT1S0/img.jpg)



 

### 메시지 전달 모델의 특징

- 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메시지 형태로 정보를 Send/Receive 하는 방법이다.
- 커널을 경유하여 메시지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링한다.
- 예를 들어, A 프로세스가 커널로 메시지를 보내면 커널이 B에게 메시지를 보내주는 방식이다.
- 프로세스 간 메모리 공유 없이 동작이 가능하다.

 

### 메시지 전달 모델의 장점

- 커널에서 데이터의 주고 받는 것을 컨트롤할 수 있어 별도의 동기화 로직이 없어도 된다.

 

### 메시지 전달 모델의 단점

- 커널을 통해서 데이터를 주고 받기 때문에 Shared Memory 모델보다 느리다.

 

### 메시지 전달 모델의 종류

**Direct Communication**

통신하려는 프로세스의 이름을 명시적으로 표시하여 메시지를 직접 전달하는 방식이다.

 



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing) - 메시지 전달 모델의 종류](https://blog.kakaocdn.net/dn/eAO0B8/btrlxgWaMGU/1f1k1FSXuTAH5yHdPdZhc1/img.png)



 

- 예를 들어 A 프로세스가 B 프로세스에게 메시지를 전달하고 싶을 때, 커널에게 직접적으로 수신자 A 프로세스가 메시지를 전달한 후 커널이 B 프로세스에게 해당 메시지를 전달하는 방식이다.
- 프로세스 간 링크는 유일하다.
- 대부분 양방향으로 구성된다.

 

**Indirect Communication**

mailbox(또는 port)를 통해 메시지를 간접 전달하는 방식이다.

 



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing) - 메시지 전달 모델의 종류](https://blog.kakaocdn.net/dn/bAjMes/btrlw2RnYoc/dA1eYsxWY0nLyCoRlquQU0/img.png)



 

- port로 전송만 하면 되기 때문에 복잡한 Communication Link를 만들 수 있으며, 다 : 다 관계가 가능하다.
- 예를 들어 A 프로세스가 B 프로세스에게 메시지를 전달하고 싶을 때, 커널 내부 특정 포트에 메시지를 저장해 놓고, B 프로세스가 해당 포트에 접근하여 메시지를 전달하는 방식이다.

 

### 메시지 전달 모델의 예시 1 : 파이프



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing) - 메시지 전달 모델의 예시 1 : 파이프](https://blog.kakaocdn.net/dn/bLU3jo/btrlw3pc1Tq/QGTFg7JPXpiP3YGZymlma1/img.webp)



 

- 두 개의 프로세스를 파이프로 연결하여 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 하며 데이터를 통신한다.
- 1:1 통신이면서 한 쪽 방향으로만 데이터가 이동한다.
- 주로 부모-자식 간의 단방향 통신으로 사용된다.
- 용량 제한이 있기 때문에 파이프가 가득 차면 더 이상 쓸 수 없다.
- 한 쪽 프로세스는 단지 읽기만 하고 다른 프로세스는 단지 쓰기만 하는 단순한 데이터 흐름에 적합하다.

 

### 메시지 전달 예시 2: 메시지 큐



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing) - 메시지 전달 예시 2: 메시지 큐](https://blog.kakaocdn.net/dn/xcdtS/btrlxfbTf1c/ruckJjWEYpLVpkBkdFI5pK/img.jpg)



 

- FIFO 자료 구조를 가지는 큐를 이용하여 데이터를 전송 및 수신하는 방식이다.
- 위의 파이프가 스트림 기반으로 동작한다면, 메시지 큐는 메시지 (또는 패킷) 단위로 동작한다.
- 부모/자식 관계가 아니더라도, 어느 프로세스 간의 데이터 송수신이 가능하다는 장점이 있다.
- 양방향 통신이 가능하며, 메시지의 형태는 사용자가 정의하여 사용할 수 있다.
- Message Queue에 쓸 데이터에 번호를 붙임으로써 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
- 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다.
- 데이터가 많이 쌓일 수록 추가적인 메모리 자원이 필요하며, 큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생할 수 있다.

 

### 메시지 전달 예시 3: 소켓



![[운영체제] IPC - IPC 모델: 메시지 전달 (Message Passing) - 메시지 전달 예시 3: 소켓](https://blog.kakaocdn.net/dn/dNYgaF/btrlwI6ICcA/V2GivlST2Cg8aJOH3IZfGK/img.png)



 

**메소드 설명**

- socket(): 소켓 생성
- bind(): 주소 할당
- listen(): 통신 요청을 기다림
- connect(): 통신 요청
- accept(): 통신 수락
- read()/write(): 통신
- close(): 소켓 종료

 

**소켓**

- socket은 네트워크 상에서 통신하기 위한 종단점으로 추상화된 개념이다.
- 소켓 통신은 흔히 네트워크 통신 기법으로 많이 사용되는 방법으로, 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고 받는 방식이다.
- 소켓이 네트워크 기능을 담고 있다 보니 네트워크 기능을 이용해 IPC로도 사용할 수 있다. 즉, 소켓을 한 PC 내 두 개의 프로세스 간 통신 기법으로도 사용이 가능하다. 기존의 네트워크 상에서 소켓 통신과 달라지는 점은 sock_addr_in 구조체를 sock_addr_un으로 변경하고, 속성을 AF_INET에 대해 AF_UNIX로 변경한 뒤 소켓 통신을 하기 위한 파일 경로가 필요하다고 한다.

 

**특징**

- 네트워크 소켓을 이용하여 Client - Server 구조로 데이터 통신을 하며, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.
- 프로세스는 포트 번호를 이용하여 통신하려는 상대 프로세스의 소켓을 찾아간다.
- 포트의 도움으로, 다른 IPC와 달리 프로세스의 위치에 독립적이며, Machine Boundary와 관계가 없기 때문에 Local 또는 Remote로 사용할 수 있다. 다른 IPC는 모두 local에서만 사용할 수 있다.
- 서버 단에서는 bind, listen, accept을 진행하여 소켓 연결을 위한 준비를 하고, 클라이언트 단에서는 connect를 통해 서버에 요청하고 연결이 수립된 후, socket에 send함으로써 데이터를 주고 받는다.
- 범용적인 IPC로서 양방향 통신이 가능하다.
- 패킷 단위로 주고 받음으로써 직관적으로 이해하기 쉬운 코드를 만들 수 있다.
- 하지만 Internet UDP와는 달리 경로를 지정할 수는 없다.



-출처-

[느리더라도 꾸준하게](https://steady-coding.tistory.com/)